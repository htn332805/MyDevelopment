#!/usr/bin/env python3
"""
Framework0 Unified Path Wrapper for Isolated Recipe Execution

This module provides unified path resolution for isolated Framework0 packages,
ensuring all file references point to local copied files for error-free execution.

Auto-generated by Framework0 Recipe Isolation CLI
"""

import os
import sys
from pathlib import Path
from typing import Optional, Dict, Any

class LocalPathResolver:
    """Resolves all file paths to local isolated package files."""
    
    def __init__(self):
        """Initialize path resolver with package root detection."""
        # Get the directory containing this wrapper file
        self.package_root = Path(__file__).parent.resolve()
        
        # Path mapping for common Framework0 directories
        self.path_mappings = {
            'orchestrator/Data': self.package_root / 'orchestrator' / 'Data',
            'orchestrator/recipes': self.package_root / 'orchestrator' / 'recipes',
            'orchestrator/context': self.package_root / 'orchestrator' / 'context',
            'orchestrator': self.package_root / 'orchestrator',
            'scriptlets': self.package_root / 'scriptlets',
            'src': self.package_root / 'src',
            'engine': self.package_root / 'engine',
            'data': self.package_root / 'data',
        }
        
        # Ensure all mapped paths exist
        for path_key, path_value in self.path_mappings.items():
            if path_value.exists():
                print(f"✓ Path available: {path_key} -> {path_value}")
        
    def resolve_path(self, original_path: str) -> str:
        """
        Resolve any Framework0 path to local package equivalent.
        
        Args:
            original_path: Original path from recipe or Framework0 code
            
        Returns:
            str: Local path within isolated package
        """
        # Convert to Path object for easier manipulation
        path_obj = Path(original_path)
        
        # If path is already absolute and exists locally, use it
        if path_obj.is_absolute() and path_obj.exists():
            return str(path_obj)
        
        # Try direct path mappings first
        for mapped_prefix, local_root in self.path_mappings.items():
            if original_path.startswith(mapped_prefix):
                # Replace prefix with local root
                relative_part = original_path[len(mapped_prefix):].lstrip('/')
                local_path = local_root / relative_part
                if local_path.exists():
                    return str(local_path)
        
        # Try relative to package root
        relative_path = self.package_root / original_path
        if relative_path.exists():
            return str(relative_path)
        
        # Try common data locations
        common_locations = [
            self.package_root / 'orchestrator' / 'Data' / path_obj.name,
            self.package_root / 'data' / path_obj.name,
            self.package_root / path_obj.name,
        ]
        
        for location in common_locations:
            if location.exists():
                return str(location)
        
        # If nothing found, return original path with warning
        print(f"⚠ Path not resolved locally: {original_path}")
        return original_path
    
    def resolve_module_path(self, module_name: str) -> Optional[str]:
        """
        Resolve module name to local file path.
        
        Args:
            module_name: Dotted module name (e.g., 'engine.steps.python.compute_numbers')
            
        Returns:
            Optional[str]: Local path to module file if found
        """
        # Convert module name to file path
        module_parts = module_name.split('.')
        
        # Try different extensions and locations
        possible_paths = [
            self.package_root / (*module_parts[:-1], f"{module_parts[-1]}.py"),
            self.package_root / (*module_parts, '__init__.py'),
            self.package_root / 'orchestrator' / (*module_parts[:-1], f"{module_parts[-1]}.py"),
            self.package_root / 'scriptlets' / (*module_parts[:-1], f"{module_parts[-1]}.py"),
            self.package_root / 'engine' / (*module_parts[:-1], f"{module_parts[-1]}.py"),
        ]
        
        for path in possible_paths:
            if path.exists():
                return str(path)
        
        return None

# Global path resolver instance
_path_resolver = None

def get_path_resolver() -> LocalPathResolver:
    """Get global path resolver instance."""
    global _path_resolver
    if _path_resolver is None:
        _path_resolver = LocalPathResolver()
    return _path_resolver

def resolve_local_path(path: str) -> str:
    """Resolve any path to local package equivalent."""
    return get_path_resolver().resolve_path(path)

def resolve_local_module(module_name: str) -> Optional[str]:
    """Resolve module name to local file path."""
    return get_path_resolver().resolve_module_path(module_name)

# Patch common path functions to use local resolver
original_open = open

def patched_open(file, mode='r', **kwargs):
    """Patched open function that resolves paths locally."""
    if isinstance(file, str):
        file = resolve_local_path(file)
    elif hasattr(file, '__fspath__'):
        file = resolve_local_path(str(file))
    return original_open(file, mode, **kwargs)

# Export patched functions
__all__ = [
    'LocalPathResolver',
    'get_path_resolver', 
    'resolve_local_path',
    'resolve_local_module',
    'patched_open'
]
